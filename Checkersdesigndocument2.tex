\documentclass[10pt]{article}
\usepackage[top=1in, bottom=1.2in]{geometry}
\linespread{1} % line spacing
\geometry{letterpaper}
\usepackage{tabularx}
\usepackage{enumitem}
\usepackage[parfill]{parskip} % begin paragraphs with an empty line rather than an indent
\usepackage[ocgcolorlinks]{hyperref} %ocg coverts links to black when you print -- downside of unbreakable lines



% New command \CustomLabel{labelname} creates a hypertarget and label for referencing
\makeatletter
 \newcommand{\CustomLabel}[1]{\Hy@raisedlink{\hypertarget{#1}{}}\label{#1}}
\makeatother

% Graph Stuff
\usepackage{tikz}
\usetikzlibrary{trees} % this is to allow the fork right path
\usetikzlibrary{calc} % for hyperlinking nodes

\usetikzlibrary{positioning}

% Styling for Graphs
\tikzset{
    basic/.style  = {thin, draw, text width=5em, font=\sffamily, rectangle, minimum size=2em, align=center},
    root/.style   = {basic},
    edge from parent fork down,
        level 2/.style = {basic, grow=down, edge from parent path={(\tikzparentnode.south) |- (\tikzchildnode.west)}},
        level 3/.style = {basic, xshift=1ex,anchor=west},
            subA/.style={level distance=6ex},
            subB/.style={level distance=12ex},
            subC/.style={level distance=18ex},
    hyperlink node/.style={
      postaction={
        path picture={
          \path let
          \p1 = (path picture bounding box.south west),
          \p2 = (path picture bounding box.north east),
          \p3 = (\x2-\x1,\y2-\y1)
          in
          (path picture bounding box.center)
          node[inner sep=0pt,anchor=center,outer sep=0pt]
          {\hyperlink{#1}{\phantom{\rule{\x3}{\y3}}}};
        }
      },
    }
}

\title{\bf Checkers Design Document}
\author{2me3}
\date{}

\begin{document} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\maketitle

\tableofcontents

\section{Introduction}
    This document contains the decomposition, uses relationship, traceability, and internal evaluation.
    Note: Red links and the Uses diagram are clickable hyperlinks (depending on your PDF reader).
    
\section{Requirements of Checkers}
	\begin{enumerate}
	\item Assignment 1 Requirements
		 \begin{enumerate}[label*=\arabic*.]
		 \item \CustomLabel{req:1.1}Must set up an 8x8 checkers board
			\begin{enumerate}[label*=\arabic*.]
				\item \CustomLabel{req:1.1.1}Squares will be either light or dark
				\item \CustomLabel{req:1.1.2}The Bottom right square must be light
			 \end{enumerate}
		\item \CustomLabel{req:1.2}User must be able to choose the standard set up
		\item \CustomLabel{req:1.3}Board Rules
			\begin{enumerate}[label*=\arabic*.]
			\item \CustomLabel{req:1.3.1} User must be able to specify starting position of each piece
			\item \CustomLabel{req:1.3.2} Notation for specifying piece location must use standard form (A7 = B)
			\item \CustomLabel{req:1.3.3} User should be able to specify type (normal or king)
			\item \CustomLabel{req:1.3.4} If they specified every pieces starting position, user must be able to indicate if the set up is complete
			\item \CustomLabel{req:1.3.5} User should be able to clear the board
			\end{enumerate}
		\item \CustomLabel{req:1.4} Maximum of 12 white and 12 black pieces can be placed on the board
		\item \CustomLabel{req:1.5} Illegal placement notification:
			\begin{enumerate}[label*=\arabic*.]
			\item \CustomLabel{req:1.5.1} User should be notified if a piece choice is illegal
			\item \CustomLabel{req:1.5.2} A piece on a light square
			\item \CustomLabel{req:1.5.3} Exceeding the maximum number
			\item \CustomLabel{req:1.5.4} Spelling/ typing error
			\item \CustomLabel{req:1.5.6} There is already a piece there
			\end{enumerate}
		\item \CustomLabel{req:1.6} User should be notified if there in an inappropriate number of pieces on the board Inappropriate includes:
			\begin{enumerate}[label*=\arabic*.]
			\item \CustomLabel{req:1.6.1} Blank board
			\end{enumerate}
		\end{enumerate}

	\item Assignment 2 Requirements	
		\begin{enumerate}[label*=\arabic*.]
		\item Load Saves \CustomLabel{req:2.1}
			\begin{enumerate}[label*=\arabic*.]
				\item \CustomLabel{req:2.1.1}
				Start Game from original starting positions
				\item \CustomLabel{req:2.1.2}
				Start a game from a previously stored state from a within a file
				\item \CustomLabel{req:2.1.3}Save a game to be resumed later
			\end{enumerate}
		\item Legal Moves and Crowning \CustomLabel{req:2.2}
			\begin{enumerate}[label*=\arabic*.]
				\item \CustomLabel{req:2.2.1} Make moves from one position to another, while making sure the move made is legal.
				\item \CustomLabel{req:2.2.2} Simply move a piece to another square; jump the opponentâ€™s piece (so that piece is removed from the board).
				\item \CustomLabel{req:2.2.3} Crowning a piece to king
				\item \CustomLabel{req:2.2.4} move kings in both directions (forwards and backwards).
				\item \CustomLabel{req:2.2.5} Graphically or through code indicate possible movements.
			\end{enumerate}
		\end{enumerate}
	\end{enumerate}

\section{Module Guide}

\subsection{Hardware Hiding Module}
    
    \subsubsection{Input Module}\CustomLabel{mod:Input}
    \begin{tabularx}{\linewidth}{ >{\bfseries}r X }
        Type            & Hardware Module \\
        Secret          & This module translates mouse clicks and keyboard presses to be used by the rest of the software. \\
        Requirements	& None \\
        Responsibilities & This module will take mouse and keyboard input and convert it to software usable states. \\
        Uses            & None \\
        Design          & \ref{mis:Input} \\
        Code File       & Inside Game1.cs, and built into C\#. \\
        Explanation     & The input module is a hardware hiding module since it translates hardware inputs to software. \\
    \end{tabularx}

\subsection{Behaviour Hiding Module}

    \subsubsection{Piece Module}\CustomLabel{mod:Piece}
        \begin{tabularx}{\linewidth}{ >{\bfseries}r X }
            Type            & Software Module \\
            Secret          & This module hides and separates specific piece information. \\
	        Requirements	& \ref{req:1.3.3} \\
            Responsibilities & This will hold the necessary components to describe what a game piece will contain, which will be separate from the game board. \\
            Uses            & None \\
            Design          & \ref{mis:Piece} \\
            Code File       & Piece.cs \\
            Explanation     & The piece is a part of behaviour hiding since the piece module holds specific piece information and outputs values needed by other modules. \\
        \end{tabularx}

\subsection{Software Decision Hiding Module}

    \subsubsection{Game1 Module}\CustomLabel{mod:Game1}
        \begin{tabularx}{\linewidth}{ >{\bfseries}r X }
            Type            & Software Module \\
            Secret          & This module hides how the graphics are displayed and how we switch between states of the game. This module has also the responsibility of giving the valid moves of any piece on the board. \\
	        Requirements	& \ref{req:1.2} \ref{req:1.3.1} \ref{req:1.3.2} \ref{req:1.3.4} \ref{req:1.3.4} \ref{req:2.2} \\
            Responsibilities & This module will be the responsible for the initial execution of the game, this class connects and launches critical components together. \\
            Uses            & \ref{mod:Board}, \ref{mod:Piece}, \ref{mod:Input} \\
            Design          & \ref{mis:Game1} \\
            Code File       & Game1.cs \\
            Explanation     & The module is a part of software decision hiding since it determines how we draw the graphics and what to do when we switch between states of the game. \\
        \end{tabularx}
        
    \subsubsection{Board Module}\CustomLabel{mod:Board}
        \begin{tabularx}{\linewidth}{ >{\bfseries}r X }
            Type            & Software Module \\
            Secret          & This module serves to hide the secret of how the board is defined internally. \\
	        Requirements	& \ref{req:1.1} \ref{req:1.3.1} \ref{req:1.3.2} \ref{req:1.3.3} \ref{req:1.3.5} \ref{req:1.4} \ref{req:1.5} \ref{req:1.6}\\            
            Responsibilities & This module is responsible for holding the necessary components and attributes to setup the board and describe piece locations. \\
            Uses            & \ref{mod:Piece} \\
            Design          & \ref{mis:Board} \\
            Code File       & Board.cs \\
            Explanation     & The board is a part of software decision hiding since the board implements a data structure that holds the placement of the pieces, this data structure might be changed for increased performance. Another software decision is deciding how to take user input to parse the placement of pieces. \\
        \end{tabularx}

   
    \subsubsection{FileIO Module}\CustomLabel{mod:LoadSave}
        \begin{tabularx}{\linewidth}{ >{\bfseries}r X }
            Type            & Software Module \\
            Secret          & This module allows the user to save the current game session as a plain text file and also load previous games by parsing the plain text file into a representation of the board. \\
            Requirements & \ref{req:1.3.2} \ref{req:2.1} \\
            Responsibilities & This module is responsible for the load and saving of the current game  \\
            Uses            & none \\
            Design          & \ref{mis:LoadSave} \\
            Code File       & FileIO.cs \\
            Explanation     & The module is a part of software decision hiding since it determines how the game will be saved and represented in a text file, and also how the file is parsed to reload a saved game file. \\
        \end{tabularx}  
        
        
        \section{Uses Relationship} 
\tikzset{main node/.style={rectangle,fill=blue!5,draw,minimum size=1cm,inner sep=0pt},
}
  \begin{tikzpicture}
    \node[main node, hyperlink node = mod:Game1] (1) {Game1};
    \node[main node, hyperlink node = mod:Board] (2) [below left = 2.3cm and 1.5cm of 1]  {Board};
    \node[main node, hyperlink node = mod:LoadSave](5) [below left =2.36cm and -1.2cm of 1] {FileIO}; 
    \node[main node, hyperlink node = mod:Piece] (3) [below left = 2.3cm and 1cm of 2] {Piece};
    \node[main node, hyperlink node = mod:Input] (4) [below right = 2.3cm and 1.5cm of 1] {Input};

    \path[draw,thick,->]
    (1) edge node {} (2)    % game1 to board
    (2) edge node {} (3)    % board to piece
    (1) edge node {} (5)    % game1 to loadsave
    (1) edge node {} (4);   % game1 to input
    %%
    
    \iffalse % this is just here in case we add more modules that aren't connected to anything
    \begin{scope}[xshift=4cm]
    \node[main node] (1) {$1$};
    \node[main node] (2) [right = 2cm  of 1] {$2$};
    \node[main node] (3) [below = 2cm  of 1] {$3$};
    \node[main node] (4) [right = 2cm  of 3] {$4$};

    \path[draw,thick]
    (1) edge node {} (2)
    (1) edge node {} (4)
    (3) edge node {} (2)
    (3) edge node {} (4)
    ;
    \end{scope}
    \fi
\end{tikzpicture}


\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Changelog from Assignment 1 to Current}

	\subsection{Board}
	\begin{itemize}
	\item if statements modified to switch colours of pieces
	\item new getPiece that takes a vector argument so that mouse clicks can be used
	\item getPiece modified to throw an exception if the piece is not found
	\item getPieceArray added to return the entire array of pieces
	\item movePiece function added 	
	\end{itemize}
	
	\subsection{Piece}
	\begin{itemize}
	\item added a validMovements struct that holds all of the information about a pieces valid movement
	\item added an enumerated variable containing the valid movement directions
	\item added a getValidMovement function that returns the array of valid movements
	\item added a setValidMovements function that gives a piece the squares it is able to move to	
	\end{itemize}
	
	\subsection{Game1}	
	\begin{itemize}
	\item new enumerated variable added: PLAYER\_TURN
	\item new variables added: currentPlayerTurn, fileIO 
	\item new Texture2D variables: Menu\_ButtonLoad, Playing\_ButtonSave
	\item new View\_Clickable: Playing\_ButtonSave, clickable\_SaveButton
	\item board\_SquareSize has been changed into a constant
	\item new Vector2 variable: mouseBoardPosition
	\item graphics changed to include new load button 
	\item switching of players turn added
	\item new restrictions on dragging ability so that pieces only moved correctly
	\item added more detailed clicking ability to restrict the movement of pieces on the correct turn
	\item actions upon clicking updated to allow for full playing
	\item takeInput function added that sets up the board if there is a file to open
	\item added setValidMovements functions to give every piece on the board the squares they can move to	
	\end{itemize}	
	
	\subparagraph{Added Module}
	\begin{itemize}
	\item added a new module FileIO to match requirement of being able to save and load games
	\end{itemize}
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Module Design (MIS and MID)}


       
    \subsection{Piece Module}\CustomLabel{mis:Piece}
    \subsubsection{Interface}
        \begin{tabularx}{\linewidth}{@{} >{\bfseries}r Xp{5cm} }
            Types           & \begin{tabular}[t]{@{} l p{8cm}} 
                                     & \\
                                    typeState & enumerate if the piece is normal or king \\
                                    player & enumerate if piece owned by Black or White \\
									validMovementStruct & structure that holds the valid movements\\
                              \end{tabular} \\
                              
            Constants       & \begin{tabular}[t]{@{} l p{8cm}} 
                                     & \\
                                    None & \\
                              \end{tabular} \\

            Access Programs & \begin{tabular}[t]{@{} l p{8cm}}
                                     & \\
                                    getType() : typeState & Retrieves the piece's current type. \\
                                    setType(newType : typeState) & Changes the piece's type. \\ 
                                    getOwner() : player & Says who owns the piece. \\
									getValidMovements() & Retrieves the movements that a piece can make.\\
									setValidMovements (direction : validMoveDirection, col : int, row : int) & Assigns the valid movements for a piece\\
                              \end{tabular}
        \end{tabularx}
        
    \subsubsection{Implementation}
        \begin{tabularx}{\linewidth}{ >{\bfseries}r Xp{5cm} }
            Variables       & \begin{tabular}[t]{@{} l p{8cm}} 
                                     & \\
                                    pieceType : typeState & holds current piece type \\
                                    owner : player & holds information of the piece's owner \\
									validMovementArray : validMovementsStruct & holds all valid movements for a piece \\
                              \end{tabular} \\

            Access Programs & \begin{tabular}[t]{@{} l l p{8cm}} 
                                     & \\
                                    \bf{getType()} : typeState & \\
                                    Inputs &  None \\
                                    Updates & None \\
                                    Outputs & pieceType \\
                                    Description & Returns the current type of the piece. \\
                                     & \\
                                    \bf{setType(newType : typeState)} & \\
                                    Inputs & newType \\
                                    Updates & None \\ 
                                    Outputs & pieceType \\
                                    Description & Changes the type of piece to the type given.\\
                                     & \\
                                    \bf{getOwner()} : player & \\
                                    Inputs & None \\
                                    Updates & None \\
                                    Outputs & owner \\ 
                                    Description & Returns which player the piece is owned by.\\
									\bf{getValidMovements()} : validMOvementsStruct[] & \\
                                    Inputs & None \\
                                    Updates & None \\ 
                                    Outputs & validMovementArray \\
                                    Description & Returns an array of the valid movements for a particular piece.\\
                                     & \\
									 \bf{setValidMovements(direction : validMoveDirection, col : int, row : int)} & \\
                                    Inputs & direction, col, row \\
                                    Updates & None \\ 
                                    Outputs & validMovementArray \\
                                    Description & Sets the places that are valid for a specific piece to move.\\
                                     & \\
							  \end{tabular} \\
                              
        \end{tabularx}
        
        
        
        
        
    \subsection{Board Module}\CustomLabel{mis:Board}
    \subsubsection{Interface}
        \begin{tabularx}{\linewidth}{@{} >{\bfseries}r Xp{5cm} }
            Types           & \begin{tabular}[t]{@{} l p{8cm}} 
                                     & \\
                                    None & \\
                              \end{tabular} \\
                              
            Constants       & \begin{tabular}[t]{@{} l p{8cm}} 
                                     & \\
                                    None & \\
                              \end{tabular} \\
            Access Programs & \begin{tabular}[t]{@{} p{4cm} p{8cm}}
                                     & \\
                                    setUpBoard() & Sets up board based on user input. \\
                                     & \\
                                    getPiece(col : int, row : int) : Piece & This method is used to get a a piece from the given (x, y) location. If the piece does exist, we pass it along to the caller. \\ 
                                     & \\
									 getPiece(location : Vector2) : Piece & This method is used to get a a piece from the given Vector. If the piece does exist, we pass it along to the caller.\\
									 & \\
									 getPieceArray() : Piece[] & Returns an array of all pieces that are currently on the board.\\
									 & \\
                                    placePiece(col : int, row : int, piece : Piece) & Places the piece on the board while checking if the placement is legal (in terms of checkers). \\
                                     & \\
                                    movePiece(fromCol : int, fromRow : int, toCol : int, toRow : int) & Moves the piece from starting to end positions while checking if the movement is valid (in terms of checkers). \\
                                     & \\
									 movePiece(originalLocation : Vector2, newLocation : Vector2) & Moves the piece from starting to end positions while checking if the movement is valid (in terms of checkers). \\
									 & \\
									 removePiece(column int, row int) & This method removes a piece off the board and will throw an exception if there is no piece at the given location.\\
									 & \\
                                    clear() & Removes all pieces from the board. \\
                             \end{tabular}
        \end{tabularx}
        
    \subsubsection{Implementation}
        \begin{tabularx}{\linewidth}{ >{\bfseries}r Xp{2cm} }
            Types           & \begin{tabular}[t]{@{} l p{8cm}} 
                                 & \\
                                None & \\
                                \end{tabular} \\
            Constants       & \begin{tabular}[t]{@{} l p{8cm}} 
                                 & \\
                                None & \\
                            \end{tabular} \\
            Variables       & \begin{tabular}[t]{@{} l p{8cm}} 
                                     & \\
                                    pieceArray : array & Contains all the Piece objects currently on the board in an array. \\
                                    numWhitePieces : int & Holds the number of white pieces on the board as an integer. \\
                                    numBlackPieces : int & Holds the number of black pieces on the board as an integer. \\
                              \end{tabular} \\
            Access Programs & \\
                            & \bf{setUpBoard(input : string)} \\
                            & \begin{tabular}[t]{@{} p{2.5cm} p{10cm}} 
                                    Inputs & input \\
                                    Outputs & pieceArray, numWhitePieces, numBlackPieces \\
                                    Updates & None \\
                                    Description & Parses input to be interpreted as Piece locations. Place Piece on correct Piece location using the PlacePiece() access program. numWhitePieces' = numWhitePieces + c and numBlackPieces' = numBlackPieces + d where c and d are between 0 and 12. pieceArray' = pieceArray with c + d more PieceObjects.\\
                                     & \\
                                     \end{tabular} \\
                            & \bf{getPiece(col : int, row : int)} : Piece \\
                            & \begin{tabular}[t]{@{} p{2.5cm} p{10cm}} 
                                    Inputs & col, row \\
                                    Outputs & piece \\
                                    Updates & None \\ 
			    Description & Returns the piece currently at the location specified. \\
                                     & \\
                                     \end{tabular} \\
							& \bf{getPiece(Location : Vector2)} : Piece \\
                            & \begin{tabular}[t]{@{} p{2.5cm} p{10cm}} 
                                    Inputs & Location \\
                                    Outputs & piece \\
                                    Updates & None \\ 
			    Description & Returns the piece currently at the location specified. \\
                                     & \\
                                     \end{tabular} \\
                            & \bf{placePiece(col : int, row : int, piece : Piece)} \\
                            & \begin{tabular}[t]{@{} p{2.5cm} p{10cm}}
                                    Inputs &  col, row, piece \\
                                    Outputs & None \\
                                    Updates & pieceArray, numWhitePieces, numBlackPieces \\ 
                                    Description & If piece placement is valid, it will put it there in the data structure. Either numWhitePieces' = numWhitePieces + 1 or numBlackPieces' = numWhitePieces + 1. pieceArray' = pieceArray with one more Piece object.\\
                                     & \\
                                     \end{tabular} \\
                            & \bf{movePiece(fromCol : int, fromRow : int, toCol : int, toRow : int)} \\
                            & \begin{tabular}[t]{@{} p{2.5cm} p{10cm}}
                                    Inputs  & fromCol, fromRow, toCol, toRow \\
                                    Outputs & None \\
                                    Updates & pieceArray \\
                                    Description & Moves piece at said location to the location specified. \\
                                     & \\
                                     \end{tabular} \\
							& \bf{movePiece(originalLocation : Vector2, newLocation : Vector2)} \\
                            & \begin{tabular}[t]{@{} p{2.5cm} p{10cm}}
                                    Inputs  & originalLocation, newLocation \\
                                    Outputs & None \\
                                    Updates & pieceArray \\
                                    Description & Moves piece at said location to the location specified. \\
                                     & \\
                                     \end{tabular} \\
							& \bf{removePiece(column : int, row : int)} \\
                            & \begin{tabular}[t]{@{} p{2.5cm} p{10cm}}
                                    Inputs  & column, row \\
                                    Outputs & None \\
                                    Updates & pieceArray \\
                                    Description & Removes the piece at the specified board location given by row and column. \\
                                     & \\
                                     \end{tabular} \\
                            & \bf{clear()} & \\
                            & \begin{tabular}[t]{@{} p{2.5cm} p{10cm}}
                                    Inputs  & None \\
                                    Outputs & pieceArray, numWhitePieces, numBlackPieces \\
                                    Updates & None \\
                                    Description & Clears the board of all pieces. pieceArray' = Array of null objects, numWhitePieces' = 0 or numBlackPieces' = 0. \\
                                     \end{tabular} \\
        \end{tabularx}
        


        
        
        
        
    \subsection{Game1 Module}\CustomLabel{mis:Game1}
    \subsubsection{Interface}
        \begin{tabularx}{\linewidth}{@{} >{\bfseries}r Xp{5cm} }
            Types           & \begin{tabular}[t]{@{} l p{8cm}} 
                                     & \\
                                    state & enumerate if the game is in Menu, Setup, Playing, or Load \\
                              \end{tabular} \\
                              
            Constants       & \begin{tabular}[t]{@{} l p{8cm}} 
                                     & \\
                                    None & \\
                              \end{tabular} \\

            Access Programs & \begin{tabular}[t]{@{} l p{8cm}}
                                     & \\
                                    Update() & Allows the game to run logic such as switching state, updating the game, and gathering input. \\
                                    Draw() & Draws the correct graphics on screen depending on the state. \\ 
                                    takeInput() & Takes user input for setting up a board. \\
                                    setValidMovements(Board : board) & Sets the valid movement for every piece. \\
                                    setValidMovements(Board : board, X : int, Y : int) & Sets the valid movement for an individual piece at a given (X,Y) location on the board. 
                              \end{tabular}
        \end{tabularx}
        
    \subsubsection{Implementation}
        \begin{tabularx}{\linewidth}{ >{\bfseries}r Xp{5cm} }
            Variables       & \begin{tabular}[t]{@{} l p{8cm}} 
                                     & \\
                                    currentState : state & holds information of the current state. \\
			    keyState : KeyboardState & holds information about the state of the keyboard. \\
                                    input : string & holds board setup from user \\ 
                                    board : Board & \\
                                    pieceList : List &  Holds information of where to graphically place each piece. \\
                              \end{tabular} \\

            Access Programs & \begin{tabular}[t]{@{} l p{8cm}} 
                                     & \\
                                    \bf{Update()} & \\
                                    Inputs &  None \\
                                    Updates & currentState \\
                                    Outputs & None \\
                                    Description & Changes the state based on keyboard press or mouse presses on graphical buttons.\\
                                     & \\
                                    \bf{Draw()} & \\
                                    Inputs & board \\
                                    Updates & pieceList \\
                                    Outputs & None \\
                                    Description & Draws the buttons, board tiles and pieces in proper place on the screen. The piece locations are stored in pieceList. And we just loop through the graphics objects to draw them each frame. \\
                                     & \\
                                    \bf{takeInput()} & \\
                                    Inputs & input \\
                                    Updates & None \\
                                    Outputs & board \\ 
                                    Description & Takes user input and sends it to the board using board.SetUpBoard().\\
                                    & \\
                                    \bf{setValidMovements(Board : board)} & \\
                                    Inputs & Board \\
                                    Updates & Board \\
                                    Outputs & None \\
                                    Description & Sets the valid movements for every Piece. Default constructor to set them for the entire board. The safe locations to move to are stored within the Pieces. The valid locations are assigned in the order: Top Left -> Top Right -> Bottom Right -> Bottom Left. The default constructor allows for calling the function with no paramaters to set up the entire board. This function loops through each piece element and calls upon setValidMovements for each individual piece to calculate the valid movements of the entire board.
                                    & \\
                                    \bf{setValidMovements(Board : board, X : int, Y : int)} & \\
                                    Inputs & Board, X , Y \\
                                    Updates & Board \\
                                    Outputs & None \\
                                    Description & Sets the valid movements for an individual Piece. The valid movements are a combination of an x direction and a y direction. initialized to a flag of an unreachable location. Game logic and checkers rule and game logic are contained within this function to judge where a piece can be placed.
                              \end{tabular} \\
                              
        \end{tabularx}







\subsection{FileIO Module}\CustomLabel{mis:LoadSave}
    \subsubsection{Interface}
        \begin{tabularx}{\linewidth}{@{} >{\bfseries}r Xp{5cm} }
            Types           & \begin{tabular}[t]{@{} l p{8cm}} 
                                     & \\
                                    None & \\
                              \end{tabular} \\
                              
            Constants       & \begin{tabular}[t]{@{} l p{8cm}} 
                                     & \\
                                    None & \\
                              \end{tabular} \\

            Access Programs & \begin{tabular}[t]{@{} l p{8cm}}
                                     & \\
                                    Save(Board : Board, Turn : Piece.player ) : void & Saves the current board state \\
                                    Load(Board : Board) : String & Loads the board with a previous board state \\ 
                              \end{tabular}
        \end{tabularx}
        
    \subsubsection{Implementation}
        \begin{tabularx}{\linewidth}{ >{\bfseries}r Xp{5cm} }
            Variables       & \begin{tabular}[t]{@{} l p{8cm}} 
                                     & \\
                                    path : String & holds the path to the location of where the save file is to be placed \\
                              \end{tabular} \\

            Access Programs & \begin{tabular}[t]{@{} l l p{8cm}} 
                                     & \\
                                    \bf{Save(Board : Board)} : typeState & \\
                                    Inputs &  Board, Turn \\
                                    Updates & None \\
                                    Outputs & None \\
                                    Description & Saves the current game session, it parses the current board array state into a text file along with the information of the current turn that the game is on. \\
                                     & \\
                                    \bf{Load(Board : Board)} & \\
                                    Inputs & Board \\
                                    Updates & None \\ 
                                    Outputs & None \\
                                    Description & Loads a new game with a previous save file. This will return an exception if there is no load file present.\\
                                     & \\
                              \end{tabular} \\
               
                                          
        \end{tabularx}
        

    \subsection{Input Module}\CustomLabel{mis:Input}
    \subsubsection{Interface}
        \begin{tabularx}{\linewidth}{@{} >{\bfseries}r Xp{5cm} }
            Types           & \begin{tabular}[t]{@{} l p{8cm}} 
                                     & \\
                                    Mouse & enumeration of mouse button states \\
                                    Keys & enumerates keyboard buttons \\
                              \end{tabular} \\
                              
            Constants       & \begin{tabular}[t]{@{} l p{8cm}} 
                                     & \\
                                    None & \\
                              \end{tabular} \\

            Access Programs & \begin{tabular}[t]{@{} l p{8cm}}
                                     & \\
                                    GetState() : Mouse & Gets if mouse button is pressed. \\
                                    IsKeyDown(key : Keys) : bool & Checks if the key is pressed. \\
                              \end{tabular}
        \end{tabularx}
        
    \subsubsection{Implementation}
        \begin{tabularx}{\linewidth}{ >{\bfseries}r Xp{5cm} }
            Variables       & \begin{tabular}[t]{@{} l p{8cm}} 
                                     & \\
                                    mouseState : Mouse & Holds if mouse is pressed. \\
                                    mouseClickedPiece & Holds the graphical object the mouse is clicking on. \\
                                    mousePos & Stores current mouse position. \\
                              \end{tabular} \\

            Access Programs & \begin{tabular}[t]{@{} l p{8cm}} 
                                     & \\
                                    \bf{GetState()} & \\
                                    Inputs &  None \\
                                    Updates & None \\
                                    Outputs & mouseState \\
                                     & \\
                                    \bf{IsKeyDown(key : Keys)} & \\
                                    Inputs & None \\
                                    Updates & None \\
                                    Outputs & None \\ 
                              \end{tabular} \\
                              
        \end{tabularx}
        
        
        
\section{Internal Evaluation}
Evidently, our design makes use of several essential design principles for simplicity and efficiency.
Our design makes use of a hierarchical structure to make the system easier to build and test. We
made use of abstraction by having the program abstract the whole game, the game abstracts the
board, the board abstracts the pieces, etc. so we could start assigning different parts to the group
right away. We also used the idea of information hiding to make things that are
likely to change private. This maximized efficiency and allowed us to get our design done very
quickly. Our design makes use of the high cohesion and low coupling principles as much as possible
to make sure our modules are meaningful when standing alone. We made a variety of decisions that improve the design, 
the following are examples.The setting of valid moves is done incredibaly efficiently. We used integer comparisons 
in the logic section and assign the valid moves to every piece which is much faster than if every piece's moves were 
stored on the piece array. Special types in the design are enumerations so they can be converted quickly. Finally, 
the Struct used combines all the information needed in one place and is very intuitive. Overall we made conscious 
decisionsin the design to ensure that the principles of software design were followed closely.

        
\end{document}